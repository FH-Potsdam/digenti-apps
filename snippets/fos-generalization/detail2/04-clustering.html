<!DOCTYPE html >
<html>
  <head>
      <meta charset='utf-8' />
      <title></title>
      <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />

      <script src='../../../lib/d3.min.js' charset="utf-8"></script>
      <script src="../../../lib/mapbox-gl.js"></script>
      <script src="../../../lib/jquery-1.10.2.js"></script>
      <script src="../../../lib/turf.min.js"></script>

      <script src="../../../lib/bundle.js"></script>

      <link href="../../../app-access/css/app.css" rel="stylesheet" />
      <!-- <link href="../../digenti-framework/css/main.css" rel="stylesheet" /> -->
      <style media="screen">
        path {
            stroke: #333 !important;
        }
      </style>
  </head>
  <body>
    <div id='map'>
    </div>
    <script>
        var concaveman = require('concaveman');
        var roadsJSON = {};

        ////////////
        // Mapbox
        ////////////

    	mapboxgl.accessToken = 'pk.eyJ1Ijoiam9yZGl0b3N0IiwiYSI6ImQtcVkyclEifQ.vwKrOGZoZSj3N-9MB6FF_A';
        var map = new mapboxgl.Map({
            container: 'map',
            // style: 'mapbox://styles/jorditost/cir1xojwe0020chknbi0y2d5t', // dark
            // style: 'mapbox://styles/jorditost/ciqc61l3p0023dunqn9e5t4zi', // light
            style: 'mapbox://styles/jorditost/ciznb3iyw00642snuu7ivnnfk', // light+nostreets
            // style: 'mapbox://styles/jorditost/cizmzgwci005l2sqjuzfvwzms', // light+streets
            // zoom: 11.5,
            // center: [-72.956, 10.410],
            // center: [-73.0770699,10.3890411], // detail
            // zoom: 13.6 // detail
            center: [-73.0848,10.3983],
            zoom: 15
        });

        // set-up svg canvas
        var svg = d3.select(map.getCanvasContainer()).append("svg").attr("id", "map-features");
        // var svg = d3.select("#svg").append("svg")
        //     .attr("height", h)
        //     .attr("width", w);

        // Path transform
        var transform = d3.geo.transform({point: projectPoint});
    	var path = d3.geo.path().projection(transform);

        // This function generates a line object out of a set of points
        var lineFunction = d3.svg.line()
                        .x(function(d) { return project(d).x; })
                        .y(function(d) { return project(d).y; })
                        .interpolate("linear");

        var gr = svg.append("g").attr("id", "group-roads");
        // var gi = svg.append("g").attr("id", "group-isolines"),
        //     gp = svg.append("g").attr("id", "group-places");

        var urlRoad = 'http://jorditost.local:61002/api/roads/336609942';
        var sourceRoad = new mapboxgl.GeoJSONSource({
            data: urlRoad
        });

        map.on('load', function () {

            // Road
            map.addSource('route', sourceRoad);
            map.addLayer({
                "id": "route",
                "type": "line",
                "source": "route",
                "layout": {
                    "line-join": "round",
                    "line-cap": "round"
                },
                "paint": {
                    'line-color': '#333',
                    'line-opacity': 1,
                    'line-width': 3
                }
            });

            loadFOS(336609942);

            // d3.json("../../../data/roads_aoi.json", function(err, data) {
            //
            //     roadsJSON = data;
            //
            //     console.log(roadsJSON);
            //
            //     // Binding the settlement data to our layer. Positions of the settlements are saved in app.villagePositionsMap-Array
            //     gr.selectAll("path")
            //         .data(roadsJSON.features)
            //         .enter()
            //         .append("path")
            //             .attr("class", "road")
            //             .attr("data-id", function(d) { return d.properties.osm_id; })
            //             // .attr("stroke-width", function(d) { d.properties.importancescore*0.4 + 1; })
            //             .attr("stroke-width", function(d) { return roadStrokeWidthByType(d.properties.type);})
            //             // .attr("d", path);
            //
            //     // for each village that is supplied by this route part
            //     for (var i=0; i<roadsJSON.features.length; i++) {
            //         var route = roadsJSON.features[i];
            //         var type = route.properties.type;
            //
            //         if (type == 'primary' ||
            //             type == 'secondary' ||
            //             type == 'tertiary' ||
            //             type == 'track' ||
            //             type == 'path' ||
            //             type == 'unclassified' ||
            //             type == 'street') {
            //                 loadFOS(route.properties.osm_id);
            //             }
            //     }
            //
            //     update();
            // });
            //
            // function update() {
            //     gr.selectAll("path")
            //         .attr("d", path);
            // }
            //
            // map.on("movestart", update);
            // map.on("moveend",   update);
            // map.on("move",      update);
        });

        function loadFOS(osmID) {

            var url = 'http://jorditost.local:61002/api/fos/road/'+osmID+'/350/';
            // var url = 'http://jorditost.local:61002/api/fos/road/'+osmID+'/400/?intersect=true';

            // Define a callback function to process the response.
            var onFOSResult = function(featureCollection) {
                var fos1 = filter(featureCollection, "fos", 1);
                processFOSResult(fos1);
            };

            // Load FOS with AJAX
            $.ajax({
                dataType: "json",
                url: url,
                success: onFOSResult,
                error: function(error) {
                    alert(error);
                }
            });

            // var source = new mapboxgl.GeoJSONSource({
            //     data: url
            // });
            //
            // map.addSource("colombia-fos-"+osmID, source);
            //
            // map.addLayer({
            //     "id": "fos3-"+osmID,
            //     "type": "fill",
            //     "source": "colombia-fos-"+osmID,
            //     "filter": ["==", "fos", 3],
            //     "paint": {
            //         "fill-color": "#F7D57F",
            //         "fill-opacity": 0.8,
            //         "fill-antialias": false
            //     }
            // });
            // map.addLayer({
            //     "id": "fos2-"+osmID,
            //     "type": "fill",
            //     "source": "colombia-fos-"+osmID,
            //     "filter": ["==", "fos", 2],
            //     "paint": {
            //         "fill-color": "#F5A623",
            //         "fill-opacity": 0.8,
            //         "fill-antialias": false
            //     }
            // });
            // map.addLayer({
            //     "id": "fos1-"+osmID,
            //     "type": "fill",
            //     "source": "colombia-fos-"+osmID,
            //     "filter": ["==", "fos", 1],
            //     "paint": {
            //         "fill-color": "#ED5D5A",
            //         "fill-opacity": 0.8,
            //         "fill-antialias": false
            //     }
            // });
        }

        function project(d) {
            return map.project(new mapboxgl.LngLat(+d[0], +d[1]));
        }

        function projectPoint(lon, lat) {
            var point = map.project(new mapboxgl.LngLat(lon, lat));
            this.stream.point(point.x, point.y);
        }

        function roadStrokeWidthByType(type) {

            var swDef = 1.39;

            if (type == 'primary') sw = 4;
            else if (type == 'secondary') sw = 3.47;
            else if (type == 'tertiary') sw = 3.47;
            else if (type == 'track') sw = swDef;
            else if (type == 'path') sw = swDef;
            else if (type == 'unclassified') sw = swDef;
            else if (type == 'street') sw = swDef;
            else sw = swDef;

            return sw;
        }

        //////////////////////////
        // Processing Functions
        //////////////////////////

        function processFOSResult(fc) {

            console.log("process - length: " + fc.features.length);

            //////////////////////
            // Buffered dataset
            //////////////////////

            // var buffered = turf.buffer(fc, 100, 'meters');
            // var reduced = turf.buffer(buffered, -100, 'meters');
            // console.log("reduced - length: " + reduced.features.length);
            // reduced = validateGeoJSON(reduced);
            // console.log("validated - length: " + reduced.features.length);
            //
            // // var sourceBuffered = new mapboxgl.GeoJSONSource({
            // //     data: reduced
            // // });
            // //
            // // map.addSource("colombia-fos-buffered", sourceBuffered);
            // // map.addLayer({
            // //     "id": "fos",
            // //     "type": "fill",
            // //     "source": "colombia-fos-buffered",
            // //     "paint": {
            // //         "fill-color": "#ED5D5A",
            // //         "fill-opacity": 0.5,
            // //         "fill-antialias": false
            // //     }
            // // });
            //
            // fc = reduced;

            //////////////////////
            // Search clusters
            //////////////////////

            var clustered = cluster(fc, 20);

            var buffered = turf.buffer(clustered, 100, 'meters');
            clustered = turf.buffer(buffered, -100, 'meters');

            // var buffered = turf.buffer(clustered, 100, 'meters');
            // clustered = turf.buffer(buffered, -100, 'meters');

            var sourceClustered = new mapboxgl.GeoJSONSource({
                data: clustered
            });

            map.addSource("colombia-fos-clustered", sourceClustered);
            map.addLayer({
                "id": "fos-c",
                "type": "fill",
                "source": "colombia-fos-clustered",
                "paint": {
                    "fill-color": "#0f0",
                    "fill-opacity": 0.5,
                    "fill-antialias": false
                }
            });

            //////////////////////
            // Original dataset
            //////////////////////
            var source = new mapboxgl.GeoJSONSource({
                data: fc
            });

            map.addSource("colombia-fos-o", source);
            map.addLayer({
                "id": "fos-o",
                "type": "fill",
                "source": "colombia-fos-o",
                "paint": {
                    "fill-color": "#ED5D5A",
                    "fill-opacity": 0.4,
                    "fill-antialias": false
                }
            });
        }

        function validateGeoJSON(collection) {
            var newFC = turf.featureCollection([]);
            for(var i = 0; i < collection.features.length; i++) {
                if(collection.features[i].geometry.coordinates[0].length > 0) {
                    newFC.features.push(collection.features[i]);
                }
            }
            return newFC;
        }

        function filter(collection, key, val) {
            var newFC = turf.featureCollection([]);
            for(var i = 0; i < collection.features.length; i++) {
                if(collection.features[i].properties[key] === val) {
                    newFC.features.push(collection.features[i]);
                }
            }
            return newFC;
        }

        function duplicate(fc) {
            var newFC = turf.featureCollection([]);
            for(var i = 0; i < fc.features.length; i++) {
                var feature = turf.feature(fc.features[i].geometry, fc.features[i].properties);
                newFC.features.push(feature);
            }
            return newFC;
        }

        function cluster(featureCollection, thres) {

            var fc = duplicate(featureCollection),//turf.featureCollection(featureCollection.features),
                clustersFC = turf.featureCollection([]);

            // var count = 0;

            while (fc.features.length > 0) {

                var intersect = false;

                // Get current polygon
                var p = fc.features[0];
                var coordArray = p.geometry.coordinates[0];      // coords array for concave hull
                var pBuffered = turf.buffer(p, thres, 'meters'); // Calculate buffer with threshold

                for (var i=1; i < fc.features.length; i++) {

                    // If intersects, merge polygons
                    if (turf.intersect(fc.features[i], pBuffered) !== undefined) {

                        // console.log("--- " + i + " intersects with " + j);

                        // Merge geometries
                        coordArray = coordArray.concat(fc.features[i].geometry.coordinates[0]);

                        // This is a clustered polygon
                        var merged = getConcaveHullFromCoordsArray(coordArray);

                        // Replace current position with the merged polygon
                        fc.features[0] = merged;

                        // Remove intersected element
                        fc.features.splice(i, 1);

                        intersect = true;

                        // count++;

                        // Abord loop
                        break;
                    }
                }

                // When the cluster has now more polygons to join add it to the clusters and remove it from the input feature collection
                if (!intersect) {
                    clustersFC.features.push(fc.features[0]);
                    fc.features.splice(0, 1);
                }
            }

            console.log("number of clusters: " + clustersFC.features.length);
            // console.log("number of operations: " + count);

            return clustersFC;
        }

        function getConcaveHullFromCoordsArray(coordArray) {

            // Calculate convex hull and update cluster from it
            var concave = concaveman(coordArray);
            return turf.polygon([concave]);
        }

        function getConvexHullFromCoordsArray(coordArray) {
            var fc = coordsArrayToFeatureCollection(coordArray);
            var hull = turf.convex(fc);
            return hull;
        }

        function coordsArrayToFeatureCollection(coordsArray) {

            var newFC = turf.featureCollection([]);
            for(var i = 0; i < coordsArray.length; i++) {
                newFC.features.push(turf.point(coordsArray[i]));
            }
            return newFC;
        }

    </script>
  </body>
</html>

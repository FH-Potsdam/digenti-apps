<!DOCTYPE html>
<html>

    <head>
        <meta charset=utf-8 />
        <title>Routing Test 03</title>
        <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
        <script src='../../lib/mapbox-gl.js'></script>
        <link href='../../lib/mapbox-gl.css' rel='stylesheet' />

        <!-- This example requires d3 for AJAX and the brush, though you can bring your own library. -->
        <script src='../../lib/d3.min.js' charset="utf-8"></script>
        <script src='../../lib/turf.min.js' charset='utf-8'></script>
        <script src='../../lib/polymorph.js' charset='utf-8'></script>
        <script src='../../lib/morphpath.js' charset='utf-8'></script>

        <script src="http://js.api.here.com/v3/3.0/mapsjs-core.js" type="text/javascript" charset="utf-8"></script>
        <script src="http://js.api.here.com/v3/3.0/mapsjs-service.js" type="text/javascript" charset="utf-8"></script>


        <style>

            #menu {
                position: relative;
                background: #fff;
                padding: 0;
                font-family: 'Futura', sans-serif;
                z-index: 3000;
                width: 100vw;
                display: flex;
                /* flex-direction: row; */
                justify-content: space-between;
                align-items: center;
            }

            #menu > * {
                padding: 10px;
            }

            html, body, #wrapper {
                width: 100%;
                height: 100%;
            	padding: 0px;
            	margin: 0px;
            }
            #map {
              position:relative;
              width: 100vw;
              height: 85%;
              margin: auto auto;
              overflow: visible;
            }

            svg {
              position: absolute;
              width: 100%;
              height: 100%;
            }

            svg.map-morphed {
                overflow: visible;
            }

            .hidden {
            	display: none;
            }

            path {
                stroke: #099;
                fill: none;
                stroke-linejoin: round;
                stroke-linecap: round;
            }

            path.route,
            path.distance {
                stroke: #099;
            }

            path.foot {
                stroke-dasharray: 4, 10;
                /*stroke: #50E3C2*/
            }

            path.time {
                stroke: #225BB1;
            }

            .villages {
                cursor: pointer;
                fill: #f33;
                stroke: none;
                fill-opacity: 0.4;
            }

            .route-dots {
                fill: #099;
                fill-opacity: 0.5;
            }

            .route-lines {
                stroke-opacity: 0.6;
            }

            .ui-brush {
                background:#f8f8f8;
                position:absolute;
                bottom:0;right:0;left:0;
                height:100px;
            }

            .brush .extent {
                stroke:#fff;
                fill-opacity:0.125;
                shape-rendering:crispEdges;
            }

        </style>
    </head>

    <body>


        <div id='menu'>

            <b>DIGENTI Routing Test</b>
            <div>
                <label>Select Basemap</label>
                <select id="basemap_select">
                    <!-- <option value="fos-outdoor selected">FOS outdoor</option> -->
                    <option value="outdoors-v9">outdoors</option>
                    <option value="basic-v9">basic</option>
                    <option value="streets-v9" selected>streets</option>
                    <option value="emerald-v8">emerald</option>
                    <option value="bright-v9">bright</option>
                    <option value="light-v9">light</option>
                    <option value="dark-v9">dark</option>
                    <option value="satellite-v9">satellite</option>
                    <option value="satellite-streets-v9">satellite streets</option>
                </select>
            </div>

            <!--<label>Pitch</label>
            <select id="pitch_select">
                <option value="0">0</option>
                <option value="10">10</option>
                <option value="20">20</option>
                <option value="30">30</option>
                <option value="40">40</option>
                <option value="50">50</option>
                <option value="60">60</option>
                <option value="70">70</option>
                <option value="80">80</option>
                <option value="90">90</option>
            </select>

            <label>Bearing</label>
            <select id="bearing_select">
                <option value="0">0</option>
                <option value="45">45</option>
                <option value="90">90</option>
                <option value="135">135</option>
                <option value="180">180</option>
                <option value="225">225</option>
                <option value="270">270</option>
                <option value="315">315</option>
                <option value="360">360</option>
            </select>-->

        </div>

        <div id='map' class='dark'></div>

        <script>

            var platform = new H.service.Platform({
              'app_id': 'EOg7UyuSFbPF0IG5ANjz',
              'app_code': 'iRnqNl0dyzX_8FOlchD0ZQ'
            });
            var router = platform.getRoutingService();


            var linePadding = 15;

            /*L.mapbox.accessToken = 'pk.eyJ1IjoiZmFiaWFuZWhtZWwiLCJhIjoiNDZiNTI3NGQxNzRiNjgxMGEwYTljYjgzZDU5ZjdjODYifQ.Mu_TWKlvON7j4UAkQ1EXJg';
            var map = L.mapbox.map('map', 'mapbox.satellite')
                .setView([0, 0], 1);*/

            d3.json("../../data/places_aoi.json", function(err, data) {
                mapDraw(data);
            });

            var currentBearing = 0;
            var currentPitch = 0;
            var routes_points = [];
            var routes_paths = [];
            var lines_paths = [];
            var routes_foot_points = [];
            var routes_foot_paths = [];
            var routing_history = [];
            var pathData, pathFootData;
            var routes_collection = [];
            var gRoutes, lineFunction;

            //mapDraw("geojson");

            function mapDraw(geojson) {

                mapboxgl.accessToken = 'pk.eyJ1Ijoiam9yZGl0b3N0IiwiYSI6ImQtcVkyclEifQ.vwKrOGZoZSj3N-9MB6FF_A';

                var map = new mapboxgl.Map({
                    container: 'map',
                    // style: 'mapbox://styles/jorditost/cip44ooh90013cjnkmwmwd2ft',
                    style: 'mapbox://styles/mapbox/streets-v9',
                    zoom: 11,
                    center: [-73.02, 10.410],
                    pitch: currentPitch, // pitch in degrees
                    bearing: currentBearing // bearing in degrees

                });

                map.addControl(new mapboxgl.Navigation());

                map.on('load', function () {
                    drawFOSLines();
                });

                function drawFOSLines() {
                    map.addSource('colombia-fos', {
                        type: 'vector',
                        url: 'mapbox://jorditost.49a7b9e1'
                    });

                    map.addLayer({
                        "id": "fos3",
                        "type": "line",
                        "source": "colombia-fos",
                        "source-layer": "colombia_fos_h1_m0_5_CLASSIFIED_wgs84",
                        "filter": ["==", "elev", 3],
                        "layout": {
                            "line-join": "round",
                            "line-cap": "round"
                        },
                        "paint": {
                            "line-color": "#e6dc51",
                            "line-width": 2,
                            "line-opacity": 0.3
                        }
                    });
                    map.addLayer({
                        "id": "fos2",
                        "type": "line",
                        "source": "colombia-fos",
                        "source-layer": "colombia_fos_h1_m0_5_CLASSIFIED_wgs84",
                        "filter": ["==", "elev", 2],
                        "layout": {
                            "line-join": "round",
                            "line-cap": "round"
                        },
                        "paint": {
                            "line-color": "#d9943f",
                            "line-width": 2,
                            "line-opacity": 0.3
                        }
                    });
                    map.addLayer({
                        "id": "fos1",
                        "type": "line",
                        "source": "colombia-fos",
                        "source-layer": "colombia_fos_h1_m0_5_CLASSIFIED_wgs84",
                        "filter": ["==", "elev", 1],
                        "layout": {
                            "line-join": "round",
                            "line-cap": "round"
                        },
                        "paint": {
                            "line-color": "#c74d4d",
                            "line-width": 2,
                            "line-opacity": 0.3
                        }
                    });
                }

                // MapboxGL container
                var container = map.getCanvasContainer()

                // d3 canvas
                var svgMorph = d3.select(container).append("svg").attr("class", "map-morphed"),
                    svg = d3.select(container).append("svg").attr("class", "map-features");

                gRoutes = svg.append("g").attr("class", "routes");
                var gLines = svgMorph.append("g").attr("class", "route-lines");

                // var svg = d3.select(container).append("svg")
                            // .attr("id", "map-features")

             	var featureElement = svg
                    .append("g")
                        .attr("class", "villages")
                        .selectAll("circle")
                		.data(geojson.features)
                		.enter()
                		.append("circle")
                    		.attr({
                                "r": 8
                    		})
                            .on("click", click);

                //This is the accessor function we talked about above
                lineFunction = d3.svg.line()
                                    .x(function(d) { return project(d).x; })
                                    .y(function(d) { return project(d).y; })
                                    .interpolate("linear");


                // This callback is called when clicking on a location
                function click(d) {
                    var coordinates = d.geometry.coordinates;

                    routing_history.push(coordinates[1]+","+coordinates[0]);

                    if (routing_history.length > 1) {
                        routingCar(coordinates);
                        //routingFoot(coordinates);
                    }
                }

                function routingCar(coordinates) {

                    // set parametes for API-call
                    var routeRequestParams = {
                            mode: 'fastest;car',
                            representation: 'display',
                            routeattributes: 'waypoints,summary,shape,legs',
                            maneuverattributes: 'direction,action',
                            waypoint0: routing_history[routing_history.length-2], // start
                            waypoint1: routing_history[routing_history.length-1], // finish
                            returnelevation: 'true'
                        };
                    // call API
                    router.calculateRoute(routeRequestParams, onSuccess, onError);

                    // case of error (hopefully not…)
                    function onError(e) { console.log(e); }

                    // succeeded!
                    function onSuccess(r) {

                        var response = r.response;

                        // initialize route from response
                        var route = {
                                init: function() {
                                    this.id = generateUniqueID();
                                    this.geometry = transformHEREgeometry(response.route[0].shape);
                                    this.travelTime = response.route[0].summary.travelTime;
                                    this.path = lineFunction(this.geometry);
                                    return this;
                                }
                            }.init();

                        // push route to collection-array
                        routes_collection.push(route);

                        // generate lineGraph
                        var lineGraph = gRoutes.append("path")
                            .attr("class", "route")
                            .attr("d", route.path)
                            .attr("stroke-width", 2)

                        // push lineGraph to array routes_paths
                        routes_paths.push(lineGraph);


                        compareRouteWithCollection(route, routes_collection);



                        // Transform routes into lines
                        setTimeout(function() {

                            // Distance
                            var line = gLines.append("path")
                                .attr("class", "distance")
                                .attr("d", route.path)
                                .attr("stroke-width", 4)

                            var linePath = morphpath.linify(route.path, 0, 10, (0.85*window.innerHeight)+10+(lines_paths.length*linePadding));

                            line
                                .transition()
                                .duration(2000)
                                // .attr("transform","translate(0,150)")
                                .attr("d", linePath);

                            // Time
                            var time = gLines.append("path")
                                .attr("class", "time")
                                .attr("d", route.path)
                                .attr("stroke-width", 4)

                            var timePath = morphpath.linify(route.path, 0, 10, (0.85*window.innerHeight)+10+(lines_paths.length*linePadding), parseInt(route.travelTime));

                            //console.log(timePath);
                            time
                                .transition()
                                .duration(2000)
                                .attr("transform","translate(0,5)")
                                .attr("d", timePath);

                            lines_paths.push(linePath);

                        }, 1000);

                        update();

                    }

                }



                function update() {

                    for (var i = 0; i < routes_paths.length; i++) {
                        routes_paths[i]
                            .attr("d", lineFunction(pathData));
                    }

                    for (var i = 0; i < routes_points.length; i++) {
                        routes_points[i]
                            .attr({
                                cx: function(d) { return project(d).x; },
                                cy: function(d) { return project(d).y; },
                            });
                    }

                    for (var i = 0; i < routes_foot_paths.length; i++) {
                        routes_foot_paths[i]
                            .attr("d", lineFunction(pathFootData));
                    }

                    for (var i = 0; i < routes_foot_points.length; i++) {
                        routes_foot_points[i]
                            .attr({
                                cx: function(d) { return project(d).x; },
                                cy: function(d) { return project(d).y; },
                            });
                    }

                    featureElement
                        .attr({
                            cx: function(d) { return project(d.geometry.coordinates).x; },
                            cy: function(d) { return project(d.geometry.coordinates).y; },
                        });
                }

                //
                map.on("viewreset", update);

/*

                map.on("rotate", function() {
            		svg.classed("hidden", true);
            	});
*/

                map.on("movestart", function() {
            		svg.classed("hidden", true);
            	});

                map.on("moveend", function() {
            		update();
            		svg.classed("hidden", false);
            	});

                //初期レンダリング
                update();

                // Use MapboxGL projection for d3 features
                function project(d) {
                    return map.project(new mapboxgl.LngLat(+d[0], +d[1]));
                }


                var basemap_select = document.getElementById('basemap_select');
                var basemap_select_options = basemap_select.options;

                basemap_select.onchange = function() {
                    var selectedValue = basemap_select_options[basemap_select.selectedIndex].value;
                    switchLayer(selectedValue);
                }

                function switchLayer(layer) {
                    if (layer == 'fos-outdoor') {
                        map.setStyle('mapbox://styles/jorditost/cip44ooh90013cjnkmwmwd2ft');
                    } else {
                        map.setStyle('mapbox://styles/mapbox/' + layer);
                    }

                    map.on('load', function () {
                        drawFOSLines();
                    });
                }


/*                var pitch_select = document.getElementById('pitch_select');
                var pitch_select_options = pitch_select.options;

                pitch_select.onchange = function() {
                    var selectedValue = pitch_select_options[pitch_select.selectedIndex].value;
                    switchPitch(parseFloat(selectedValue));
                }

                function switchPitch(value) {
                    currentPitch = value;
                    flyMap();
                }


                var bearing_select = document.getElementById('bearing_select');
                var bearing_select_options = bearing_select.options;

                bearing_select.onchange = function() {
                    var selectedValue = bearing_select_options[bearing_select.selectedIndex].value;
                    switchBearing(parseFloat(selectedValue));
                }

                function switchBearing(value) {
                    currentBearing = value;
                    flyMap();
                }*/

/*                function flyMap() {
                    map.flyTo({
                        // These options control the ending camera position: centered at
                        // the target, at zoom level 9, and north up.
                        bearing: currentBearing,
                        pitch: currentPitch,

                        // These options control the flight curve, making it move
                        // slowly and zoom out almost completely before starting
                        // to pan.
                        speed: 1, // make the flying slow
                        curve: 1, // change the speed at which it zooms out

                        // This can be any easing function: it takes a number between
                        // 0 and 1 and returns another number between 0 and 1.
                        easing: function (t) {
                            return t;
                        }
                    });
                }*/

            }

            ////////////////
            // Math Utils
            ////////////////

            function getRandomInt(min, max) {
                return Math.floor(Math.random() * (max - min)) + min;
            }


            function generateUniqueID() {
                return 'id' + (new Date).getTime().toString() + Math.random().toString(36).substr(2, 16);
            };


            // Transform data from HERE API
            function transformHEREgeometry(pathData) {

                for (var i=0; i<pathData.length; i++) {
                    pathData[i] = pathData[i].split(",");
                    for (var j=0; j<pathData[i].length; j++) {
                        pathData[i][j] = parseFloat(pathData[i][j]);
                    }
                    var temp = pathData[i][0];
                    pathData[i][0] = pathData[i][1];
                    pathData[i][1] = temp;
                }

                return pathData;
            }

            // Returns overlapping geometry of two path arrays of points of a line
            function getOverlappingGeometry(geometry1, geometry2) {

                var overlappingGeometry = [];

                for (var i=0; i<geometry1.length; i++) {
                    for (var j=0; j<geometry2.length; j++) {
                        if (geometry1[i].equals(geometry2[j])) {
                            overlappingGeometry.push(geometry1[i]);
                        }
                    }
                }

                return overlappingGeometry;

            }



            // Warn if overriding existing method
            if(Array.prototype.equals)
                console.warn("Overriding existing Array.prototype.equals. Possible causes: New API defines the method, there's a framework conflict or you've got double inclusions in your code.");
            // attach the .equals method to Array's prototype to call it on any array
            Array.prototype.equals = function (array) {
                // if the other array is a falsy value, return
                if (!array)
                    return false;

                // compare lengths - can save a lot of time
                if (this.length != array.length)
                    return false;

                for (var i = 0, l=this.length; i < l; i++) {
                    // Check if we have nested arrays
                    if (this[i] instanceof Array && array[i] instanceof Array) {
                        // recurse into the nested arrays
                        if (!this[i].equals(array[i]))
                            return false;
                    }
                    else if (this[i] != array[i]) {
                        // Warning - two different object instances will never be equal: {x:20} != {x:20}
                        return false;
                    }
                }
                return true;
            }
            // Hide method from for-in loops
            Object.defineProperty(Array.prototype, "equals", {enumerable: false});






            function compareRouteWithCollection(r, c) {
                if (c.length > 1) {
                    for (var i=0; i<c.length; i++) {
                        if (r.id !== c[i].id) {
                            var overlapping_route = getOverlappingGeometry(r.geometry, c[i].geometry);
                            if (overlapping_route.length>0) {
                                var test123 = gRoutes.append("path")
                                    .attr("class", "route")
                                    .attr("d", lineFunction(overlapping_route))
                                    .attr("stroke-width", 8)
                                routes_paths.push(test123);
                            }
                        }
                    }
                }
            }







        </script>
    </body>
</html>
